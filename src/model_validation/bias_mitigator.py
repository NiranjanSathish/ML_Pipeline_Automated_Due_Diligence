import json
import os
from typing import List, Dict
from src.config import BIAS_CONFIG

class BiasMitigator:
    """
    Mitigates bias by adjusting retrieval scores for underrepresented groups.
    Uses the bias report generated by bias_check.py.
    """
    
    def __init__(self, bias_report_path: str = "src/model_validation/bias_report.json"):
        self.bias_report_path = bias_report_path
        self.boost_factor = BIAS_CONFIG["boost_factor"]
        self.min_score_threshold = BIAS_CONFIG["min_score_threshold"]
        self.bias_map = self._load_bias_map()
    
    def _load_bias_map(self) -> Dict[str, float]:
        """
        Load bias report and identify groups that need boosting.
        Returns a map of group_id -> boost_multiplier (currently just 1.0 or boost_factor)
        """
        if not os.path.exists(self.bias_report_path):
            return {}
            
        try:
            with open(self.bias_report_path, 'r') as f:
                report = json.load(f)
            
            bias_map = {}
            per_group = report.get("per_group", {})
            
            for group_id, stats in per_group.items():
                # Check if group is underperforming
                avg_score = stats.get("avg_overall_score", 1.0)
                
                if avg_score < self.min_score_threshold:
                    bias_map[group_id] = self.boost_factor
            
            return bias_map
            
        except Exception as e:
            print(f"Error loading bias report: {e}")
            return {}

    def adjust_scores(self, chunks: List[Dict], group_id: str = None) -> List[Dict]:
        """
        Adjust scores for chunks belonging to a specific group.
        If group_id is provided (e.g. from query analysis), boost scores if needed.
        """
        if not group_id or group_id not in self.bias_map:
            return chunks
            
        boost = self.bias_map[group_id]
        
        for chunk in chunks:
            # Boost the final_score (from reranker)
            if 'final_score' in chunk:
                chunk['final_score'] *= boost
                chunk['bias_boosted'] = True
                chunk['boost_factor'] = boost
        
        # Re-sort after boosting
        chunks.sort(key=lambda x: x.get('final_score', 0), reverse=True)
        
        return chunks
